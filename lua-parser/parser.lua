
local viewer = require("loop.debug.Viewer"){nolabels=true,noindices=true}
local function show(msg, ...)
  io.write(msg)
  viewer:write(...)
  print()
end



--[[
This module implements a parser for Lua 5.3 with LPeg,
and generates an Abstract Syntax Tree that is similar to the one generated by Metalua.
For more information about Metalua, please, visit:
https://github.com/fab13n/metalua-parser

block: { stat* }

stat:
    `Do{ stat* }
  | `Set{ {lhs+} {expr+} }                    -- lhs1, lhs2... = e1, e2...
  | `While{ expr block }                      -- while e do b end
  | `Repeat{ block expr }                     -- repeat b until e
  | `If{ (expr block)+ block? }               -- if e1 then b1 [elseif e2 then b2] ... [else bn] end
  | `Fornum{ ident expr expr expr? block }    -- for ident = e, e[, e] do b end
  | `Forin{ {ident+} {expr+} block }          -- for i1, i2... in e1, e2... do b end
  | `Local{ {ident+} {expr+}? }               -- local i1, i2... = e1, e2...
  | `Localrec{ ident expr }                   -- only used for 'local function'
  | `Goto{ <string> }                         -- goto str
  | `Label{ <string> }                        -- ::str::
  | `Return{ <expr*> }                        -- return e1, e2...
  | `Break                                    -- break
  | apply

expr:
    `Nil
  | `Dots
  | `Boolean{ <boolean> }
  | `Number{ <number> }
  | `String{ <string> }
  | `Function{ { `Id{ <string> }* `Dots? } block }
  | `Table{ ( `Pair{ expr expr } | expr )* }
  | `Op{ opid expr expr? }
  | `Paren{ expr }       -- significant to cut multiple values returns
  | apply
  | lhs

apply:
    `Call{ expr expr* }
  | `Invoke{ expr `String{ <string> } expr* }

lhs: `Id{ <string> } | `Index{ expr expr }

opid:  -- includes additional operators from Lua 5.3 and all relational operators
    'add'  | 'sub' | 'mul'  | 'div'
  | 'idiv' | 'mod' | 'pow'  | 'concat'
  | 'band' | 'bor' | 'bxor' | 'shl' | 'shr'
  | 'eq'   | 'ne'  | 'lt'   | 'gt'  | 'le'   | 'ge'
  | 'and'  | 'or'  | 'unm'  | 'len' | 'bnot' | 'not'
]]

local lpeg = require "lpeglabel"

lpeg.locale(lpeg)

local P, S, V = lpeg.P, lpeg.S, lpeg.V
local C, Carg, Cb, Cc = lpeg.C, lpeg.Carg, lpeg.Cb, lpeg.Cc
local Cf, Cg, Cmt, Cp, Cs, Ct = lpeg.Cf, lpeg.Cg, lpeg.Cmt, lpeg.Cp, lpeg.Cs, lpeg.Ct
local Lc, T = lpeg.Lc, lpeg.T

local alpha, digit, alnum = lpeg.alpha, lpeg.digit, lpeg.alnum
local xdigit = lpeg.xdigit

local grammar = require "lua-parser.grammar"

-- error message auxiliary functions

local labels = {
  { "ErrExtra", "unexpected character(s), expected EOF" },
  { "ErrInvalidStat", "unexpected token, invalid start of statement" },

  { "ErrEndIf", "expected 'end' to close the if statement" },
  { "ErrExprIf", "expected a condition after 'if'" },
  { "ErrThenIf", "expected 'then' after the condition" },
  { "ErrExprEIf", "expected a condition after 'elseif'" },
  { "ErrThenEIf", "expected 'then' after the condition" },

  { "ErrEndDo", "expected 'end' to close the do block" },
  { "ErrExprWhile", "expected a condition after 'while'" },
  { "ErrDoWhile", "expected 'do' after the condition" },
  { "ErrEndWhile", "expected 'end' to close the while loop" },
  { "ErrUntilRep", "expected 'until' at the end of the repeat loop" },
  { "ErrExprRep", "expected a conditions after 'until'" },

  { "ErrForRange", "expected a numeric or generic range after 'for'" },
  { "ErrEndFor", "expected 'end' to close the for loop" },
  { "ErrExprFor1", "expected a starting expression for the numeric range" },
  { "ErrCommaFor", "expected ',' to split the start and end of the range" },
  { "ErrExprFor2", "expected an ending expression for the numeric range" },
  { "ErrExprFor3", "expected a step expression for the numeric range after ','" },
  { "ErrInFor", "expected '=' or 'in' after the variable(s)" },
  { "ErrEListFor", "expected one or more expressions after 'in'" },
  { "ErrDoFor", "expected 'do' after the range of the for loop" },

  { "ErrDefLocal", "expected a function definition or assignment after local" },
  { "ErrNameLFunc", "expected a function name after 'function'" },
  { "ErrEListLAssign", "expected one or more expressions after '='" },
  { "ErrEListAssign", "expected one or more expressions after '='" },

  { "ErrFuncName", "expected a function name after 'function'" },
  { "ErrNameFunc1", "expected a function name after '.'" },
  { "ErrNameFunc2", "expected a method name after ':'" },
  { "ErrOParenPList", "expected '(' for the parameter list" },
  { "ErrCParenPList", "expected ')' to close the parameter list" },
  { "ErrEndFunc", "expected 'end' to close the function body" },
  { "ErrParList", "expected a variable name or '...' after ','" },

  { "ErrLabel", "expected a label name after '::'" },
  { "ErrCloseLabel", "expected '::' after the label" },
  { "ErrGoto", "expected a label after 'goto'" },
  { "ErrRetList", "expected an expression after ',' in the return statement" },

  { "ErrVarList", "expected a variable name after ','" },
  { "ErrExprList", "expected an expression after ','" },

  { "ErrOrExpr", "expected an expression after 'or'" },
  { "ErrAndExpr", "expected an expression after 'and'" },
  { "ErrRelExpr", "expected an expression after the relational operator" },
  { "ErrBOrExpr", "expected an expression after '|'" },
  { "ErrBXorExpr", "expected an expression after '~'" },
  { "ErrBAndExpr", "expected an expression after '&'" },
  { "ErrShiftExpr", "expected an expression after the bit shift" },
  { "ErrConcatExpr", "expected an expression after '..'" },
  { "ErrAddExpr", "expected an expression after the additive operator" },
  { "ErrMulExpr", "expected an expression after the multiplicative operator" },
  { "ErrUnaryExpr", "expected an expression after the unary operator" },
  { "ErrPowExpr", "expected an expression after '^'" },

  { "ErrExprParen", "expected an expression after '('" },
  { "ErrCParenExpr", "expected ')' to close the expression" },
  { "ErrNameIndex", "expected a field name after '.'" },
  { "ErrExprIndex", "expected an expression after '['" },
  { "ErrCBracketIndex", "expected ']' to close the indexing expression" },
  { "ErrNameMeth", "expected a method name after ':'" },
  { "ErrMethArgs", "expected some arguments for the method call (or '()')" },

  { "ErrArgList", "expected an expression after ',' in the argument list" },
  { "ErrCParenArgs", "expected ')' to close the argument list" },

  { "ErrCBraceTable", "expected '}' to close the table constructor" },
  { "ErrEqField", "expected '=' after the table key" },
  { "ErrExprField", "expected an expression after '='" },
  { "ErrExprFKey", "expected an expression after '[' for the table key" },
  { "ErrCBracketFKey", "expected ']' to close the table key" },

  { "ErrDigitHex", "expected one or more hexadecimal digits after '0x'" },
  { "ErrDigitDeci", "expected one or more digits after the decimal point" },
  { "ErrDigitExpo", "expected one or more digits for the exponent" },

  { "ErrQuote", "unclosed string" },
  { "ErrHexEsc", "expected exactly two hexadecimal digits after '\\x'" },
  { "ErrOBraceUEsc", "expected '{' after '\\u'" },
  { "ErrDigitUEsc", "expected one or more hexadecimal digits for the UTF-8 code point" },
  { "ErrCBraceUEsc", "expected '}' after the code point" },
  { "ErrEscSeq", "invalid escape sequence" },
  { "ErrCloseLStr", "unclosed long string" },
}

local function throw(label)
  label = "Err" .. label
  for i, labelinfo in ipairs(labels) do
    if labelinfo[1] == label then
      return T(i)
    end
  end

  error("Label not found: " .. label)
end

local function expect (patt, label)
  return patt + throw(label)
end


-- regular combinators and auxiliary functions

local function tagC (tag, patt)
  return Ct(Cg(Cp(), "pos") * Cg(Cc(tag), "tag") * patt)
end

local function unaryOp (op, e)
  return { tag = "Op", pos = e.pos, [1] = op, [2] = e }
end

local viewer = require("loop.debug.Viewer"){noindices=true,nolabels=true,linebreak=false}

local function binaryOp (e1, op, e2)
  if not op then
    return e1
  else
    return { tag = "Op", pos = e1.pos, [1] = op, [2] = e1, [3] = e2 }
  end
end

local function chainOp (patt)
  return Cf(patt, binaryOp)
end

local function tagDo (block)
  block.tag = "Do"
  return block
end

local function fixFuncStat (func)
  if func[1].is_method then table.insert(func[2][1], 1, { tag = "Id", [1] = "self" }) end
  func[1] = {func[1]}
  func[2] = {func[2]}
  return func
end

local function fixLocalAssign (assign)
  if assign[2] == nil then assign[2] = {} end
  return assign
end

local function addDots (params, dots)
  if dots then table.insert(params, dots) end
  return params
end

local function insertIndex (t, index)
  return { tag = "Index", pos = t.pos, [1] = t, [2] = index }
end

local function markMethod(t, method)
  if method then
    return { tag = "Index", pos = t.pos, is_method = true, [1] = t, [2] = method }
  end
  return t
end

local function makeIndexOrCall (t1, t2)
  if t2 == nil then return t1 end
  if t2.tag == "Call" or t2.tag == "Invoke" then
    local t = { tag = t2.tag, pos = t1.pos, [1] = t1 }
    for k, v in ipairs(t2) do
      table.insert(t, v)
    end
    return t
  end
  return { tag = "Index", pos = t1.pos, [1] = t1, [2] = t2[1] }
end

local function fill(src, dst)
  for key, value in pairs(src) do
    if dst[key] == nil then
      dst[key] = value
    end
  end
  return dst
end

-- grammar
local G = fill(grammar, { V"Lua",
  Block       = tagC("Block", grammar.Block);
  IfStat      = tagC("If", grammar.IfStat);

  DoStat      = grammar.DoStat / tagDo;
  WhileStat   = tagC("While", grammar.WhileStat);
  RepeatStat  = tagC("Repeat", grammar.RepeatStat);

  ForNum      = tagC("Fornum", grammar.ForNum);
  ForIn       = tagC("Forin", grammar.ForIn);

  LocalFunc   = tagC("Localrec", grammar.LocalFunc) / fixFuncStat;
  LocalAssign = tagC("Local", grammar.LocalAssign) / fixLocalAssign;
  Assignment  = tagC("Set", grammar.Assignment);

  FuncStat    = tagC("Set", grammar.FuncStat) / fixFuncStat;
  FuncName    = Cf(grammar.FuncNamePfx, insertIndex) * grammar.FuncNameSfx / markMethod;
  FuncBody    = tagC("Function", grammar.FuncBody);
  ParList     = grammar.ParamDecl / addDots
              + Ct(V"Dots")
              + Ct(Cc()); -- Cc({}) generates a bug since the {} would be shared across parses

  LabelStat  = tagC("Label", grammar.LabelStat);
  GoToStat   = tagC("Goto", grammar.GoToStat);
  BreakStat  = tagC("Break", grammar.BreakStat);
  RetStat    = tagC("Return", grammar.RetStat);

  NameList  = tagC("NameList", grammar.NameList);
  VarList   = tagC("VarList", grammar.VarList);
  ExprList  = tagC("ExpList", grammar.ExprList);

  OrExpr      = chainOp(grammar.OrExpr);
  AndExpr     = chainOp(grammar.AndExpr);
  RelExpr     = chainOp(grammar.RelExpr);
  BOrExpr     = chainOp(grammar.BOrExpr);
  BXorExpr    = chainOp(grammar.BXorExpr);
  BAndExpr    = chainOp(grammar.BAndExpr);
  ShiftExpr   = chainOp(grammar.ShiftExpr);
  ConcatExpr  = grammar.ConcatExpr / binaryOp;
  AddExpr     = chainOp(grammar.AddExpr);
  MulExpr     = chainOp(grammar.MulExpr);
  UnaryExpr   = grammar.UnaryExpr / unaryOp;
  PowExpr     = grammar.PowExpr / binaryOp;

  Dots = tagC("Dots", grammar.Dots);

  Nil = tagC("Nil", grammar.Nil);

  Boolean = tagC("Boolean", grammar.Boolean);
  False   = grammar.False * Cc(false);
  True    = grammar.True * Cc(true);

  CallExpr  = Cmt(V"SuffixedExpr", function(s, i, exp, ...) return exp.tag == "Call" or exp.tag == "Invoke", exp end);
  VarExpr   = Cmt(V"SuffixedExpr", function(s, i, exp, ...) return exp.tag == "Id" or exp.tag == "Index", exp end);

  SuffixedExpr  = Cf(grammar.SuffixedExpr, makeIndexOrCall);
  ParenExpr     = tagC("Paren", grammar.ParenExpr);
  DotIndex      = tagC("DotIndex", grammar.DotIndex);
  ArrayIndex    = tagC("ArrayIndex", grammar.ArrayIndex);
  Invoke        = tagC("Invoke", Cg(grammar.Invoke));
  Call          = tagC("Call", grammar.Call);

  Table      = tagC("Table", grammar.Table);
  Field      = tagC("Pair", grammar.Field);

  Id     = tagC("Id", grammar.Id);
  StrId  = tagC("String", grammar.StrId);

  -- lexer
  LongComment = grammar.LongComment / function () return end;

  Ident     = C(grammar.Ident);

  Number   = tagC("Number", grammar.Number / tonumber);

  String    = tagC("String", grammar.String);

  EscSeq = P"\\" / ""  -- remove backslash
         * ( P"a" / "\a"
           + P"b" / "\b"
           + P"f" / "\f"
           + P"n" / "\n"
           + P"r" / "\r"
           + P"t" / "\t"
           + P"v" / "\v"
           
           + P"\n" / "\n"
           + P"\r" / "\n"
           
           + P"\\" / "\\"
           + P"\"" / "\""
           + P"\'" / "\'"
           
           + grammar.EscSpc / ""
           
           + grammar.ChaDec / tonumber / string.char
           + P"x" * expect(C(grammar.ChaHex), "HexEsc") * Cc(16) / tonumber / string.char
           + P"u" * expect("{", "OBraceUEsc")
                  * expect(C(grammar.UniHex), "DigitUEsc") * Cc(16)
                  * expect("}", "CBraceUEsc")
                  / tonumber 
                  / (utf8 and utf8.char or string.char)  -- true max is \u{10FFFF}
                                                         -- utf8.char needs Lua 5.3
                                                         -- string.char works only until \u{FF}
           
           + throw("EscSeq")
           );
  QStrData = Cs(grammar.QStrData);
  ShortStr = grammar.ShortStr / function (s, quote) return s end;
  LongStr  = grammar.LongStr / function (s, eqs) return s end;
  LStrData = C(grammar.LStrData);

  OrOp      = grammar.OrOp      / "or";
  AndOp     = grammar.AndOp     / "and";
  NotEqOp   = grammar.NotEqOp   / "ne";
  EqualOp   = grammar.EqualOp   / "eq";
  LessEqOp  = grammar.LessEqOp  / "le";
  GreatEqOp = grammar.GreatEqOp / "ge";
  LesserOp  = grammar.LesserOp  / "lt";
  GreaterOp = grammar.GreaterOp / "gt";
  BOrOp     = grammar.BOrOp     / "bor";
  BXorOp    = grammar.BXorOp    / "bxor";
  BAndOp    = grammar.BAndOp    / "band";
  LShiftOp  = grammar.LShiftOp  / "shl";
  RShiftOp  = grammar.RShiftOp  / "shr";
  ConcatOp  = grammar.ConcatOp  / "concat";
  SumOp     = grammar.SumOp     / "add";
  SubOp     = grammar.SubOp     / "sub";
  MulOp     = grammar.MulOp     / "mul";
  IntDivOp  = grammar.IntDivOp  / "idiv";
  DivOp     = grammar.DivOp     / "div";
  ModOp     = grammar.ModOp     / "mod";
  NotOp     = grammar.NotOp     / "not";
  NegOp     = grammar.NegOp     / "unm";
  SizeOp    = grammar.SizeOp    / "len";
  BNotOp    = grammar.BNotOp    / "bnot";
  PowOp     = grammar.PowOp     / "pow";
})

local parser = {}

local validator = require("lua-parser.validator")
local validate = validator.validate
local syntaxerror = validator.syntaxerror

function parser.parse (subject, filename)
  local errorinfo = { subject = subject, filename = filename }
  lpeg.setmaxstack(1000)
  local ast, label, sfail = lpeg.match(G, subject, nil, errorinfo)
  if not ast then
    local errpos = #subject-#sfail+1
    local errmsg = labels[label][2]
    return ast, syntaxerror(errorinfo, errpos, errmsg)
  end
  return validate(ast, errorinfo)
end

return parser
