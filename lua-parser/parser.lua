
local viewer = require("loop.debug.Viewer"){nolabels=true,noindices=true}
local function show(msg, ...)
  io.write(msg)
  viewer:write(...)
  print()
end



--[[
This module implements a parser for Lua 5.3 with LPeg,
and generates an Abstract Syntax Tree that is similar to the one generated by Metalua.
For more information about Metalua, please, visit:
https://github.com/fab13n/metalua-parser

block: { stat* }

stat:
    `Do{ stat* }
  | `Set{ {lhs+} {expr+} }                    -- lhs1, lhs2... = e1, e2...
  | `While{ expr block }                      -- while e do b end
  | `Repeat{ block expr }                     -- repeat b until e
  | `If{ (expr block)+ block? }               -- if e1 then b1 [elseif e2 then b2] ... [else bn] end
  | `Fornum{ ident expr expr expr? block }    -- for ident = e, e[, e] do b end
  | `Forin{ {ident+} {expr+} block }          -- for i1, i2... in e1, e2... do b end
  | `Local{ {ident+} {expr+}? }               -- local i1, i2... = e1, e2...
  | `Localrec{ ident expr }                   -- only used for 'local function'
  | `Goto{ <string> }                         -- goto str
  | `Label{ <string> }                        -- ::str::
  | `Return{ <expr*> }                        -- return e1, e2...
  | `Break                                    -- break
  | apply

expr:
    `Nil
  | `Dots
  | `Boolean{ <boolean> }
  | `Number{ <number> }
  | `String{ <string> }
  | `Function{ { `Id{ <string> }* `Dots? } block }
  | `Table{ ( `Pair{ expr expr } | expr )* }
  | `Op{ opid expr expr? }
  | `Paren{ expr }       -- significant to cut multiple values returns
  | apply
  | lhs

apply:
    `Call{ expr expr* }
  | `Invoke{ expr `String{ <string> } expr* }

lhs: `Id{ <string> } | `Index{ expr expr }

opid:  -- includes additional operators from Lua 5.3 and all relational operators
    'add'  | 'sub' | 'mul'  | 'div'
  | 'idiv' | 'mod' | 'pow'  | 'concat'
  | 'band' | 'bor' | 'bxor' | 'shl' | 'shr'
  | 'eq'   | 'ne'  | 'lt'   | 'gt'  | 'le'   | 'ge'
  | 'and'  | 'or'  | 'unm'  | 'len' | 'bnot' | 'not'
]]

local lpeg = require "lpeglabel"

lpeg.locale(lpeg)

local P, S, V = lpeg.P, lpeg.S, lpeg.V
local C, Carg, Cb, Cc = lpeg.C, lpeg.Carg, lpeg.Cb, lpeg.Cc
local Cf, Cg, Cmt, Cp, Cs, Ct = lpeg.Cf, lpeg.Cg, lpeg.Cmt, lpeg.Cp, lpeg.Cs, lpeg.Ct
local Lc, T = lpeg.Lc, lpeg.T

local alpha, digit, alnum = lpeg.alpha, lpeg.digit, lpeg.alnum
local xdigit = lpeg.xdigit

local lua53 = require "lua-parser.grammar"

-- regular combinators and auxiliary functions

local function tagC (tag, patt)
  return Ct(Cg(Cp(), "pos") * Cg(Cc(tag), "tag") * patt)
end

local function unaryOp (op, e)
  return { tag = "Op", pos = e.pos, [1] = op, [2] = e }
end

local viewer = require("loop.debug.Viewer"){noindices=true,nolabels=true,linebreak=false}

local function binaryOp (e1, op, e2)
  if not op then
    return e1
  else
    return { tag = "Op", pos = e1.pos, [1] = op, [2] = e1, [3] = e2 }
  end
end

local function chainOp (patt)
  return Cf(patt, binaryOp)
end

local function tagDo (block)
  block.tag = "Do"
  return block
end

local function fixForStat (spec, body)
  table.insert(spec, body)
  return spec
end

local function fixFuncStat (func)
  if func[1].is_method then table.insert(func[2][1], 1, { tag = "Id", [1] = "self" }) end
  func[1] = {func[1]}
  func[2] = {func[2]}
  return func
end

local function fixLocalAssign (assign)
  if assign[2] == nil then assign[2] = {} end
  return assign
end

local function addDots (params, dots)
  if dots then table.insert(params, dots) end
  return params
end

local function insertIndex (t, index)
  if index.tag == "DotIndex" then index = index[1] end
  return { tag = "Index", pos = t.pos, [1] = t, [2] = index }
end

local function markMethod(t, method)
  if method then
    return { tag = "Index", pos = t.pos, is_method = true, [1] = t, [2] = method }
  end
  return t
end

local function makeIndexOrCall (t1, t2)
  if t2 == nil then return t1 end
  if t2.tag == "Call" or t2.tag == "Invoke" then
    local t = { tag = t2.tag, pos = t1.pos, [1] = t1 }
    for k, v in ipairs(t2) do
      table.insert(t, v)
    end
    return t
  end
  return { tag = "Index", pos = t1.pos, [1] = t1, [2] = t2[1] }
end

local function fill(src, dst)
  for key, value in pairs(src) do
    if dst[key] == nil then
      dst[key] = value
    end
  end
  return dst
end

local escval = {
  ["a"] = "\a",
  ["b"] = "\b",
  ["f"] = "\f",
  ["n"] = "\n",
  ["r"] = "\r",
  ["t"] = "\t",
  ["v"] = "\v",
  ["\n"] = "\n",
  ["\r"] = "\n",
  ["\\"] = "\\",
  ["\""] = "\"",
  ["\'"] = "\'",
}

-- true max is \u{10FFFF}
-- utf8.char needs Lua 5.3
-- string.char works only until \u{FF}
local utf8char = utf8 and utf8.char or string.char

local grammar = lua53.grammar
local G = fill(grammar, { V"Lua",
  Block       = tagC("Block", grammar.Block);
  IfStat      = tagC("If", grammar.IfStat);

  DoStat      = grammar.DoStat / tagDo;
  WhileStat   = tagC("While", grammar.WhileStat);
  RepeatStat  = tagC("Repeat", grammar.RepeatStat);

  ForStat     = grammar.ForStat / fixForStat;
  ForNumSpec  = tagC("Fornum", grammar.ForNumSpec);
  ForInSpec   = tagC("Forin", grammar.ForInSpec);

  LocalFunc   = tagC("Localrec", grammar.LocalFunc) / fixFuncStat;
  LocalVar    = tagC("Local", grammar.LocalVar) / fixLocalAssign;

  Assignment  = tagC("Set", grammar.Assignment);

  FuncStat    = tagC("Set", grammar.FuncStat) / fixFuncStat;
  FuncName    = Cf(V"Name" * (V"Skip" * V"FieldIndex")^0, insertIndex)
              * (V"Skip" * V"MethodIndex")^-1 / markMethod;
  FuncBody    = tagC("Function", grammar.FuncBody);
  FuncParSpec = grammar.FuncParName / addDots
              + Ct(V"Dots")
              + Ct(Cc()); -- Cc({}) generates a bug since the {} would be shared across parses

  LabelStat  = tagC("Label", grammar.LabelStat);
  GoToStat   = tagC("Goto", grammar.GoToStat);
  BreakStat  = tagC("Break", grammar.BreakStat);
  RetStat    = tagC("Return", grammar.RetStat);

  NameList  = tagC("NameList", grammar.NameList);
  VarList   = tagC("VarList", grammar.VarList);
  ExprList  = tagC("ExpList", grammar.ExprList);

  OrExpr      = chainOp(grammar.OrExpr);
  AndExpr     = chainOp(grammar.AndExpr);
  RelExpr     = chainOp(grammar.RelExpr);
  BOrExpr     = chainOp(grammar.BOrExpr);
  BXorExpr    = chainOp(grammar.BXorExpr);
  BAndExpr    = chainOp(grammar.BAndExpr);
  ShiftExpr   = chainOp(grammar.ShiftExpr);
  ConcatExpr  = grammar.ConcatExpr / binaryOp;
  SumExpr     = chainOp(grammar.SumExpr);
  ProdExpr    = chainOp(grammar.ProdExpr);
  UnaryExpr   = grammar.UnaryExpr / unaryOp;
  PowExpr     = grammar.PowExpr / binaryOp;

  SuffixedExpr  = Cf(grammar.SuffixedExpr, makeIndexOrCall);
  ParenExpr     = tagC("Paren", grammar.ParenExpr);
  FieldIndex    = tagC("DotIndex", grammar.FieldIndex);
  ArrayIndex    = tagC("ArrayIndex", grammar.ArrayIndex);
  MethodCall    = tagC("Invoke", Cg(grammar.MethodCall));
  FuncCall      = tagC("Call", grammar.FuncCall);

  Table        = tagC("Table", grammar.Table);
  TabEntryPair = tagC("Pair", grammar.TabEntryPair);

  Name  = tagC("Id", grammar.Name);
  Field = tagC("String", grammar.Field);

  -- Lexer ---------------------------------------------------------------------

  -- Comments
  LongComment = grammar.LongComment / function () return end; -- discard capture in 'DbSqBkData'

  -- Identifiers
  Identifier = C(grammar.Identifier);

  -- Special Values
  Dots = tagC("Dots", grammar.Dots);
  Nil  = tagC("Nil", grammar.Nil);

  -- Booleans
  Boolean = tagC("Boolean", grammar.Boolean);
  False   = grammar.False * Cc(false);
  True    = grammar.True * Cc(true);

  -- Numbers
  Number = tagC("Number", grammar.Number / tonumber);

  -- Strings
  String        = tagC("String", grammar.String);
  DbSqBkData    = C(grammar.DbSqBkData); -- capture only the contents in 'LongString'
  QuoteData     = Cs(grammar.QuoteData); -- capture contents replacing escapes in 'QuoteString'
  QtEscSymbol   = grammar.QtEscSymbol / ""; -- remove backslash
  QtEscChar     = grammar.QtEscChar / escval;
  QtEscSpace    = grammar.QtEscSpace / ""; -- remove escaped space
  QtEscHexa     = grammar.QtEscHexa * Cc(16) / tonumber / string.char;
  QtEscUnicode  = grammar.QtEscUnicode * Cc(16) / tonumber / utf8char;
  CharCodeDec   = grammar.CharCodeDec / tonumber / string.char;
  CharCodeHex   = C(grammar.CharCodeHex); -- capture only hex code in 'QtEscHexa'
  UnicodeHex    = C(grammar.UnicodeHex); -- capture only hex code in 'QtEscUnicode'

  -- Operators
  OrOp      = grammar.OrOp      / "or";
  AndOp     = grammar.AndOp     / "and";
  NotEqOp   = grammar.NotEqOp   / "ne";
  EqualOp   = grammar.EqualOp   / "eq";
  LessEqOp  = grammar.LessEqOp  / "le";
  GreatEqOp = grammar.GreatEqOp / "ge";
  LesserOp  = grammar.LesserOp  / "lt";
  GreaterOp = grammar.GreaterOp / "gt";
  BOrOp     = grammar.BOrOp     / "bor";
  BXorOp    = grammar.BXorOp    / "bxor";
  BAndOp    = grammar.BAndOp    / "band";
  LShiftOp  = grammar.LShiftOp  / "shl";
  RShiftOp  = grammar.RShiftOp  / "shr";
  ConcatOp  = grammar.ConcatOp  / "concat";
  AddOp     = grammar.AddOp     / "add";
  SubOp     = grammar.SubOp     / "sub";
  MulOp     = grammar.MulOp     / "mul";
  IntDivOp  = grammar.IntDivOp  / "idiv";
  DivOp     = grammar.DivOp     / "div";
  ModOp     = grammar.ModOp     / "mod";
  NotOp     = grammar.NotOp     / "not";
  NegOp     = grammar.NegOp     / "unm";
  SizeOp    = grammar.SizeOp    / "len";
  BNotOp    = grammar.BNotOp    / "bnot";
  PowOp     = grammar.PowOp     / "pow";
})

local parser = {}

local validator = require("lua-parser.validator")
local validate = validator.validate
local syntaxerror = validator.syntaxerror

function parser.parse (subject, filename)
  local errorinfo = { subject = subject, filename = filename }
  lpeg.setmaxstack(1000)
  local ast, erridx, sfail = lpeg.match(G, subject, nil, errorinfo)
  if not ast then
    local errpos = #subject-#sfail+1
    local errmsg = lua53.errors[erridx][2]
    return ast, syntaxerror(errorinfo, errpos, errmsg)
  end
  return validate(ast, errorinfo)
end

return parser
