--[[
This module implements a parser for Lua 5.3 with LPeg,
and generates an Abstract Syntax Tree that is similar to the one generated by Metalua.
For more information about Metalua, please, visit:
https://github.com/fab13n/metalua-parser

block: { stat* }

stat:
    `Do{ stat* }
  | `Set{ {lhs+} {expr+} }                    -- lhs1, lhs2... = e1, e2...
  | `While{ expr block }                      -- while e do b end
  | `Repeat{ block expr }                     -- repeat b until e
  | `If{ (expr block)+ block? }               -- if e1 then b1 [elseif e2 then b2] ... [else bn] end
  | `Fornum{ ident expr expr expr? block }    -- for ident = e, e[, e] do b end
  | `Forin{ {ident+} {expr+} block }          -- for i1, i2... in e1, e2... do b end
  | `Local{ {ident+} {expr+}? }               -- local i1, i2... = e1, e2...
  | `Localrec{ ident expr }                   -- only used for 'local function'
  | `Goto{ <string> }                         -- goto str
  | `Label{ <string> }                        -- ::str::
  | `Return{ <expr*> }                        -- return e1, e2...
  | `Break                                    -- break
  | apply

expr:
    `Nil
  | `Dots
  | `Boolean{ <boolean> }
  | `Number{ <number> }
  | `String{ <string> }
  | `Function{ { `Id{ <string> }* `Dots? } block }
  | `Table{ ( `Pair{ expr expr } | expr )* }
  | `Op{ opid expr expr? }
  | `Paren{ expr }       -- significant to cut multiple values returns
  | apply
  | lhs

apply:
    `Call{ expr expr* }
  | `Invoke{ expr `String{ <string> } expr* }

lhs: `Id{ <string> } | `Index{ expr expr }

opid:  -- includes additional operators from Lua 5.3 and all relational operators
    'add'  | 'sub' | 'mul'  | 'div'
  | 'idiv' | 'mod' | 'pow'  | 'concat'
  | 'band' | 'bor' | 'bxor' | 'shl' | 'shr'
  | 'eq'   | 'ne'  | 'lt'   | 'gt'  | 'le'   | 'ge'
  | 'and'  | 'or'  | 'unm'  | 'len' | 'bnot' | 'not'
]]

local lpeg = require "lpeglabel"

lpeg.locale(lpeg)

local P, S, V = lpeg.P, lpeg.S, lpeg.V
local C, Carg, Cb, Cc = lpeg.C, lpeg.Carg, lpeg.Cb, lpeg.Cc
local Cf, Cg, Cmt, Cp, Cs, Ct = lpeg.Cf, lpeg.Cg, lpeg.Cmt, lpeg.Cp, lpeg.Cs, lpeg.Ct
local Lc, T = lpeg.Lc, lpeg.T

local alpha, digit, alnum = lpeg.alpha, lpeg.digit, lpeg.alnum
local xdigit = lpeg.xdigit

local lua53 = require "lua-parser.grammar"

-- regular combinators and auxiliary functions

local function tagC (tag, patt)
  return Ct(Cg(Cp(), "pos") * Cg(Cc(tag), "tag") * patt)
end

local function unaryOp (op, e)
  return { tag = "Op", pos = e.pos, [1] = op, [2] = e }
end

local function binaryOp (e1, ...)
  for index = 1, select("#", ...), 2 do
    local op, e2 = select(index, ...)
    if op ~= nil then
      e1 = { tag = "Op", pos = e1.pos, [1] = op, [2] = e1, [3] = e2 }
    end
  end
  return e1
end

local function chainOp (patt)
  return patt / binaryOp
end

local function tagDo (block)
  block.tag = "Do"
  return block
end

local function fixForStat (spec, body)
  table.insert(spec, body)
  return spec
end

local function fixFuncStat (func)
  if func[1].is_method then
    table.insert(func[2][1], 1, { tag = "Id", [1] = "self" })
  end
  func[1] = {func[1]}
  func[2] = {func[2]}
  return func
end

local function fixLocalAssign (assign)
  if assign[2] == nil then assign[2] = {} end
  return assign
end

local function addDots (params, dots)
  if dots then table.insert(params, dots) end
  return params
end

local function fixFuncName (name, ...)
  for i = 1, select("#", ...) do
    local suffix = select(i, ...)
    name = { tag = "Index", pos = name.pos, name }
    if suffix.tag == "DotIndex" then
      name[2] = suffix[1] -- field as a string value
    else -- suffix.tag == "Invoke"
      name.is_method = true
      name[2] = suffix
    end
  end
  return name
end

local function makeIndexOrCall (t1, t2)
  if t2 == nil then return t1 end
  if t2.tag == "Call" or t2.tag == "Invoke" then
    local t = { tag = t2.tag, pos = t1.pos, [1] = t1 }
    for k, v in ipairs(t2) do
      table.insert(t, v)
    end
    return t
  end
  return { tag = "Index", pos = t1.pos, [1] = t1, [2] = t2[1] }
end

local function fill(src, dst)
  for key, value in pairs(src) do
    if dst[key] == nil then
      dst[key] = value
    end
  end
  return dst
end

local escval = {
  ["a"] = "\a",
  ["b"] = "\b",
  ["f"] = "\f",
  ["n"] = "\n",
  ["r"] = "\r",
  ["t"] = "\t",
  ["v"] = "\v",
  ["\n"] = "\n",
  ["\r"] = "\n",
  ["\\"] = "\\",
  ["\""] = "\"",
  ["\'"] = "\'",
}

--[[
local tags = {
  Shebang
  Block
    IfStat
      IfPart
      ElseIfPart
      ElsePart
    DoStat
    WhileStat
    RepeatStat
    ForStat
      ForInSpec
      ForNumSpec
        ForNumRange
        ForNumStep
    LocalStat
      LocalFunc
      LocalVar
    FuncStat
      FuncName
      FuncBody

  NameList
  ExprList

  Expression

  FieldIndex
  MethodIndex

  Skip
}
--]]

local grammar = lua53.grammar
local G = fill(grammar, { V"Lua",
  FuncParName = grammar.NameList
              * (sVs"Comma" * expect(V"Dots", "FuncParSpec"))^-1;

  Block      = tagC("Block"     , grammar.Block);
  --Expression = tagC("Expression", grammar.Expression);

  IfStat = tagC("If", grammar.IfStat);
  --IfPart = tagC("IfPart", grammar.IfPart);

  DoStat      = grammar.DoStat / tagDo;
  WhileStat   = tagC("While", grammar.WhileStat);
  RepeatStat  = tagC("Repeat", grammar.RepeatStat);

  ForStat     = grammar.ForStat / fixForStat;
  ForNumSpec  = tagC("Fornum", grammar.ForNumSpec);
  ForInSpec   = tagC("Forin", grammar.ForInSpec);

  LocalFunc   = tagC("Localrec", grammar.LocalFunc) / fixFuncStat;
  LocalVar    = tagC("Local", grammar.LocalVar) / fixLocalAssign;

  Assignment  = tagC("Set", grammar.Assignment);

  FuncStat    = tagC("Set", grammar.FuncStat) / fixFuncStat;
  FuncName    = grammar.FuncName / fixFuncName;
  FuncBody    = tagC("Function", grammar.FuncBody);
  FuncParSpec = grammar.FuncParName / addDots
              + Ct(V"Dots")
              + Ct(Cc()); -- Cc({}) generates a bug since the {} would be shared across parses

  LabelStat  = tagC("Label", grammar.LabelStat);
  GoToStat   = tagC("Goto", grammar.GoToStat);
  BreakStat  = tagC("Break", grammar.BreakStat);
  RetStat    = tagC("Return", grammar.RetStat);

  NameList  = tagC("NameList", grammar.NameList);
  VarList   = tagC("VarList", grammar.VarList);
  ExprList  = tagC("ExpList", grammar.ExprList);

  OrExpr      = chainOp(grammar.OrExpr);
  AndExpr     = chainOp(grammar.AndExpr);
  RelExpr     = chainOp(grammar.RelExpr);
  BOrExpr     = chainOp(grammar.BOrExpr);
  BXorExpr    = chainOp(grammar.BXorExpr);
  BAndExpr    = chainOp(grammar.BAndExpr);
  ShiftExpr   = chainOp(grammar.ShiftExpr);
  ConcatExpr  = grammar.ConcatExpr / binaryOp;
  SumExpr     = chainOp(grammar.SumExpr);
  ProdExpr    = chainOp(grammar.ProdExpr);
  UnaryExpr   = grammar.UnaryExpr / unaryOp;
  PowExpr     = grammar.PowExpr / binaryOp;

  SuffixedExpr  = Cf(grammar.SuffixedExpr, makeIndexOrCall);
  ParenExpr     = tagC("Paren", grammar.ParenExpr);
  FieldIndex    = tagC("DotIndex", grammar.FieldIndex);
  ArrayIndex    = tagC("ArrayIndex", grammar.ArrayIndex);
  MethodCall    = tagC("Invoke", Cg(grammar.MethodCall));
  FuncCall      = tagC("Call", grammar.FuncCall);

  Table        = tagC("Table", grammar.Table);
  TabEntryPair = tagC("Pair", grammar.TabEntryPair);

  Name  = tagC("Id", grammar.Name);
  Field = tagC("String", grammar.Field);

  -- Lexer ---------------------------------------------------------------------

  -- Whitespace
  Space = tagC("Space", C(grammar.Space));

  -- Comments
  Comment     = tagC("Comment", grammar.Comment);
  LineComment = P"--" * C((P(1) - P"\n")^0);

  -- Identifiers
  Identifier = C(grammar.Identifier);

  -- Strings
  String     = tagC("String", grammar.String);
  DbSqBkData = C(grammar.DbSqBkData);
  QuoteData  = C(grammar.QuoteData);

  -- Numbers
  Number = tagC("Number", grammar.Number);

  -- Special Values
  Nil   = tagC("Nil"  , grammar.Nil);
  False = tagC("False", grammar.False);
  True  = tagC("True" , grammar.True);
  Dots  = tagC("Dots" , grammar.Dots);

  -- Operators
  OrOp      = grammar.OrOp      / "or";
  AndOp     = grammar.AndOp     / "and";
  NotEqOp   = grammar.NotEqOp   / "ne";
  EqualOp   = grammar.EqualOp   / "eq";
  LessEqOp  = grammar.LessEqOp  / "le";
  GreatEqOp = grammar.GreatEqOp / "ge";
  LesserOp  = grammar.LesserOp  / "lt";
  GreaterOp = grammar.GreaterOp / "gt";
  BOrOp     = grammar.BOrOp     / "bor";
  BXorOp    = grammar.BXorOp    / "bxor";
  BAndOp    = grammar.BAndOp    / "band";
  LShiftOp  = grammar.LShiftOp  / "shl";
  RShiftOp  = grammar.RShiftOp  / "shr";
  ConcatOp  = grammar.ConcatOp  / "concat";
  AddOp     = grammar.AddOp     / "add";
  SubOp     = grammar.SubOp     / "sub";
  MulOp     = grammar.MulOp     / "mul";
  IntDivOp  = grammar.IntDivOp  / "idiv";
  DivOp     = grammar.DivOp     / "div";
  ModOp     = grammar.ModOp     / "mod";
  NotOp     = grammar.NotOp     / "not";
  NegOp     = grammar.NegOp     / "unm";
  SizeOp    = grammar.SizeOp    / "len";
  BNotOp    = grammar.BNotOp    / "bnot";
  PowOp     = grammar.PowOp     / "pow";
})

local errors = require("lua-parser.errors")
local geterrmsg = errors.getmsgbyidx

local validator = require("lua-parser.validator")
local syntaxerror = validator.syntaxerror

local function parse (subject, filename)
  local errorinfo = { subject = subject, filename = filename }
  lpeg.setmaxstack(1000)
  local ast, erridx, sfail = lpeg.match(G, subject, nil, errorinfo)
  if not ast then
    local errpos = #subject-#sfail+1
    local errmsg = geterrmsg(erridx)
    return ast, syntaxerror(errorinfo, errpos, errmsg)
  end
  return ast
end

local printer = {}

local function printElement(value)
  local tagPrinter = assert(printer[value.tag], "unknown element tag")
  return tagPrinter(value)
end

function printer.Block(list)
  for _, value in ipairs(list) do
    printElement(value)
  end
end

local file = assert(io.open(..., "r"))
local contents = assert(file:read("a"))
file:close()

local src = assert(parse(contents, ...))



local Viewer = require "loop.debug.Viewer"
local viewer = Viewer{
  nolabels = true,
  noindices = true,
}

viewer:write(src)
print()